#include "/script/Akachron/lib/include_system.txt"



float _humes = 0.9; //unit of realness - 1.0 is "baseline", 0.9 seems a good baseline for Babel
int _numActiveEffects = 0;

@Initialize
{
	_Main();
}

@MainLoop
{
	yield;
}

@Event
{
	//TODO: Events to manually trigger a specific effect
	//and probably an event to set the hume level because using common data for that is probably teeeeeechnically jank?
}

task _Main()
{
	let humePointer = LoadCommonDataValuePointer("HUME_LEVEL", _humes);
	loop
	{
		if(IsValidCommonDataValuePointer(humePointer)) _humes = GetCommonDataPtr(humePointer, _humes);
		
		if(_humes < 1.0 & rand(-0.01, _humes * (_numActiveEffects + 0.1)) < 0.1)
		{
			_DeadRegion(_humes);
		}
		
		yield;
	}
}

task _DeadRegion(float thresh_)
{	
	string renderTarg = "RENDERTARGET_SCREENSHOT" ~ ToString(rand_int(0, 9999));
	CreateRenderTarget(renderTarg);
	
	const int lower = 20;
	const int upper = 40;
	const int objPri = PRI_BACKGROUND + 10;
	const int stgOffL = 0;
	const int stgOffT = 0;
	
	int playerDist = 999;
	
	SetInvalidRenderPriorityA1(lower, upper);
	RenderToTextureA1(renderTarg, lower, upper, false);
	ClearInvalidRenderPriority();
	
	yield;
	
	int prim = ObjPrim_Create(OBJ_PRIMITIVE_2D);
	ObjPrim_SetPrimitiveType(prim, PRIMITIVE_TRIANGLELIST);
	ObjPrim_SetVertexCount(prim, 3);
	ObjPrim_SetTexture(prim, renderTarg);
	Obj_SetRenderPriorityI(prim, objPri);
	
	float centerX = rand(0, GetScreenWidth());
	float centerY = rand(0, GetScreenHeight());
	while(distance(centerX, centerY, GetPlayerX()+stgOffL, GetPlayerY()+stgOffT) <= 50)
	{
		centerX = rand(0, GetScreenWidth());	
		centerY = rand(0, GetScreenHeight());	
	}
	
	float offsetX = rand(-2, 2);
	float offsetY = rand(-2, 2);

	
	float[] xVerts = [];
	float[] yVerts = [];
	ascent(i in 0..3)
	{
		float th = rand(i * 120, (i+1) * 100);
		float r = rand(10, rand(40, 100));
		
		xVerts = xVerts ~ [ centerX + r * cos(th) ];
		yVerts = yVerts ~ [ centerY + r * sin(th) ];
		
		ObjPrim_SetVertexPosition(prim, i, xVerts[i] + offsetX, yVerts[i] + offsetY, 0);
		ObjPrim_SetVertexUVT(prim, i, xVerts[i], yVerts[i]);
	}
	
	
	_numActiveEffects++;
	
	int frame = 0;
	
	while(_humes <= 1.0 
	&& (rand(0, 1000) > 1) 
	&& (frame < 600) 
	//&& playerDist > 50
	)
	{
		playerDist = distance(centerX, centerY, GetPlayerX()+stgOffL, GetPlayerY()+stgOffT);
		if(rand(0,1000) < frame)
		{
			ObjRender_SetPosition(prim, rand(-1, 1), rand(-1, 1), 0);
			ObjRender_SetColor(prim, rand(200, 255), rand(200, 255), rand(200, 255));
		}
		else if(rand(0, 30) < 1)
		{
			Obj_SetVisible(prim, false);
			SetInvalidRenderPriorityA1(lower, upper);
			RenderToTextureA1(renderTarg, lower, upper, false);
			ClearInvalidRenderPriority();
			Obj_SetVisible(prim, true);
		}
		
		if(playerDist < 50) AddScore(10);
		
		frame++;
		yield;
	}
	
	if(playerDist <= 50)
	{
		AddScore(1000);
		//if(GetPlayerSpell() < 1) SetPlayerSpell(clamp(GetPlayerSpell() + 0.5, 0, 1)); //refill up to one bomb charge
		//if(GetPlayerLife() < 5) SetPlayerLife(clamp(GetPlayerLife() + 0.05, 0, 5));
	}
	
	descent(i in 0..30)
	{
		ObjRender_SetPosition(prim, rand(-1, 1), rand(-1, 1), 0);
		ObjRender_SetAlpha(prim, 255 * i / 30);
		yield;
	}
	
	Obj_Delete(prim);
	RemoveTexture(renderTarg);
	ClearRenderTargetA1(renderTarg);
	
	wait(300); //give it some time before the threshold for creating more lowers again
	_numActiveEffects--;
}