#include "/script/Akachron/lib/lib_image.txt"

function CreateGenericAkashicDemon(let _isBoss)
{
	let enemyType;
	if(typeof(_isBoss) == VAR_BOOL) enemyType = _isBoss ? OBJ_ENEMY_BOSS : OBJ_ENEMY;
	else enemyType = _isBoss;
	let objEnemy = ObjEnemy_Create(enemyType);
	ObjEnemy_Regist(objEnemy);
	
	Obj_SetRenderPriorityI(objEnemy, PRI_ENEMY);
	
	let imgDemon = DIR_IMAGE ~ "/GenericAkashicDemon.png";
	ObjPrim_SetTexture(objEnemy, imgDemon);
	ObjSprite2D_SetSourceRect(objEnemy, 0, 0, 63, 63);
	ObjSprite2D_SetDestCenter(objEnemy);
	
	ObjEnemy_SetLife(objEnemy, 300);
	if(enemyType == OBJ_ENEMY) ObjEnemy_SetDamageRate(objEnemy, 1.0, 1.0);
	else ObjEnemy_SetDamageRate(objEnemy, 0.1, 0.1);
	
	async
	{
		int count = rand(0, 2047);
		yield; //give time to set anything manual the loop will need to take into account
		bool doScale = Obj_GetValueD(objEnemy, "DO_SCALE", true);
		
		while(!Obj_IsDeleted(objEnemy) && ObjEnemy_GetInfo(objEnemy, INFO_LIFE) > 0)
		{
			count += rand(-2,4); //jittery movement that makes it slightly unsettling
			ObjRender_SetAngleZ(objEnemy, count*15);
			if(doScale) ObjRender_SetScaleXYZ(objEnemy, 1 + 0.1 * sin(count*30), 1 - 0.1 * cos(count*32), 1);
			
			ObjEnemy_SetIntersectionCircleToShot(objEnemy,   ObjMove_GetX(objEnemy), ObjMove_GetY(objEnemy), 32);
			ObjEnemy_SetIntersectionCircleToPlayer(objEnemy, ObjMove_GetX(objEnemy), ObjMove_GetY(objEnemy), 24);
			
			yield;
		}
		//TODO: Little explosion effect if they died
		if(!Obj_IsDeleted(objEnemy))
		{
			_EffectEnemyBurst(ObjMove_GetX(objEnemy), ObjMove_GetY(objEnemy));
			ExPlaySE(SE_SHOT_QUIET); //because i don't currently have any sound effects other than shot
			AddScore(1000);
		}
		Obj_Delete(objEnemy);
	}
	return objEnemy;
}

function CreateGenericBabelDemon(){
	//int obj = CreateGenericAkashicDemon(OBJ_ENEMY);
	int obj = CreateEnemy(OBJ_ENEMY);
	ObjRender_SetScaleXYZ(obj, 0.75, 0.75, 1);
	_FiddleWithDemon(obj, true);
	//Obj_SetValue(obj, "DO_SCALE", false);
	return obj;
}


func _FiddleWithDemon(int objEnemy_){ _FiddleWithDemon(objEnemy_, true); }
task _FiddleWithDemon(int objEnemy_, bool doScale_)
{
	int count = rand(0, 2047);
	bool doScale = Obj_GetValueD(objEnemy_, "DO_SCALE", true);
	float baseScaleX = ObjRender_GetScaleX(objEnemy_);
	float baseScaleY = ObjRender_GetScaleY(objEnemy_);
	
	while(!Obj_IsDeleted(objEnemy_) && ObjEnemy_GetInfo(objEnemy_, INFO_LIFE) > 0)
	{
		count += rand(-2,4); //jittery movement that makes it slightly unsettling
		ObjRender_SetAngleZ(objEnemy_, count*15);
		if(doScale) ObjRender_SetScaleXYZ(objEnemy_, baseScaleX + 0.1 * sin(count*30), baseScaleY - 0.1 * cos(count*32), 1);
		yield;
	}
}



//Adaptable to whatever the needs are
function CreateEnemy(){ return CreateEnemy(OBJ_ENEMY, true); }
function CreateEnemy(let type_){ return CreateEnemy(type_, true); }
function CreateEnemy(let type_, bool doIntersection_)
{
	int objEnemy = ObjEnemy_Create(type_);
	ObjEnemy_Regist(objEnemy);
	Obj_SetRenderPriorityI(objEnemy, PRI_ENEMY);
	let imgDemon = DIR_IMAGE ~ "/GenericAkashicDemon.png";
	ObjPrim_SetTexture(objEnemy, imgDemon);
	ObjSprite2D_SetSourceRect(objEnemy, 0, 0, 63, 63);
	ObjSprite2D_SetDestCenter(objEnemy);
	ObjEnemy_SetLife(objEnemy, 300);
	ObjEnemy_SetDamageRate(objEnemy, 1.0, 1.0);
	if(type_ == OBJ_ENEMY_BOSS) ObjEnemy_SetDamageRate(objEnemy, 0.1, 0.1);
	
	async
	{
		while(!Obj_IsDeleted(objEnemy) && ObjEnemy_GetInfo(objEnemy, INFO_LIFE) > 0)
		{
			if(doIntersection_)
			{
				float scale = (ObjRender_GetScaleX(objEnemy) + ObjRender_GetScaleY(objEnemy)) / 2;
				ObjEnemy_SetIntersectionCircleToShot(objEnemy,   ObjMove_GetX(objEnemy), ObjMove_GetY(objEnemy), 32 * scale);
				ObjEnemy_SetIntersectionCircleToPlayer(objEnemy, ObjMove_GetX(objEnemy), ObjMove_GetY(objEnemy), 24 * scale);
			}
			yield;
		}
		if(!Obj_IsDeleted(objEnemy))
		{
			_EffectEnemyBurst(ObjMove_GetX(objEnemy), ObjMove_GetY(objEnemy));
			ExPlaySE(SE_SHOT_QUIET); //because i don't currently have any sound effects other than shot
			int pointVal = 10 * round(100 / ObjEnemy_GetInfo(objEnemy, INFO_DAMAGE_RATE_SHOT));
			AddScore(pointVal); //tankier enemies are worth more
			Obj_Delete(objEnemy);
		}
	}
	
	return objEnemy;
}


func<int[]> CreateDemonCloud(int enemyType_)
{
	int actualEnemyObj = CreateEnemy(enemyType_);
	
	Obj_SetVisible(actualEnemyObj, false);
	int[] fakes = [];
	float[] thetas = [];
	float[] radii  = [];
	float[] plungeMults = [];
	ascent(i in 0..15)
	{
		int obj = Create2DSprite(DIR_IMAGE ~ "/GenericAkashicDemon.png", 0, 0, 63, 63);
		fakes = fakes ~ [obj];
		thetas = thetas ~ [rand(0, 360)];
		radii = radii ~ [rand(5, 75)];
		plungeMults  = plungeMults ~ [rand(0, 3)];
	}
	async
	{
		int count = 0;
		while(!Obj_IsDeleted(actualEnemyObj) && ObjEnemy_GetInfo(actualEnemyObj, INFO_LIFE) > 0)
		{
			float ex = ObjRender_GetX(actualEnemyObj);
			float ey = ObjRender_GetY(actualEnemyObj);

			ObjEnemy_SetIntersectionCircleToShot(  actualEnemyObj, ex, ey, 64);
			ObjEnemy_SetIntersectionCircleToPlayer(actualEnemyObj, ex, ey, 48);
			
			for each(i, fake in fakes)
			{
				//float r = (50 - sqrt(i+1) * 15) * sin(count * sqrt(i + 1)) + rand(-5, 5) + 10 * i;
				//float th = 45 * i + 360 * sin(count * 1.7 * sqrt(i + 1)) + rand(-5, 5);
				thetas[i] = thetas[i] + rand(0, 5) * (-1.0f)^i;
				float r  = radii[i] * cos(count * plungeMults[i]);
				float th = thetas[i];
				
				ObjRender_SetPosition(fake, ex + r * cos(th), ey + r * sin(th), 0);
				ObjRender_SetAngleZ(fake, count * i + rand(-20, 20));
			}
			count++;
			yield;
		}
		for each(fake in fakes) 
		{
			Obj_Delete(fake);
		}
	}
	return [actualEnemyObj] ~ fakes;
}